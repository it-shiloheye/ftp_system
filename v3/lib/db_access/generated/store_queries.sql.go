// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: store_queries.sql

package db_access

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const downloadStoreBulk = `-- name: DownloadStoreBulk :many
SELECT file_metadata.id, dir_id, file_path, file_type, file_metadata.file_state, file_data_id, file_mode, file_metadata.mod_time, file_metadata.creation_time, file_tracker.id, peer_id, file_meta_id, current_hash_id, file_tracker.file_state, log_time, file_data.id, file_hash, file_data.mod_time, file_size, file_data_b, file_data.creation_time from file_metadata
JOIN file_tracker on file_tracker.file_meta_id = file_metadata.id
JOIN file_data on file_tracker.current_hash_id = file_data.id
WHERE 
	current_hash_id NOT IN (
		SELECT current_hash_id from file_metadata 
		where file_state = 'stored'
		AND peer_id = $1
	)
`

type DownloadStoreBulkRow struct {
	ID             int32              `json:"id"`
	DirID          *int32             `json:"dir_id"`
	FilePath       string             `json:"file_path"`
	FileType       string             `json:"file_type"`
	FileState      string             `json:"file_state"`
	FileDataID     int32              `json:"file_data_id"`
	FileMode       int32              `json:"file_mode"`
	ModTime        pgtype.Timestamptz `json:"mod_time"`
	CreationTime   pgtype.Timestamptz `json:"creation_time"`
	ID_2           int32              `json:"id_2"`
	PeerID         uuid.UUID          `json:"peer_id"`
	FileMetaID     int32              `json:"file_meta_id"`
	CurrentHashID  int32              `json:"current_hash_id"`
	FileState_2    string             `json:"file_state_2"`
	LogTime        pgtype.Timestamptz `json:"log_time"`
	ID_3           int32              `json:"id_3"`
	FileHash       *string            `json:"file_hash"`
	ModTime_2      pgtype.Timestamptz `json:"mod_time_2"`
	FileSize       int32              `json:"file_size"`
	FileDataB      []byte             `json:"file_data_b"`
	CreationTime_2 pgtype.Timestamptz `json:"creation_time_2"`
}

// DownloadStoreBulk
//
//	SELECT file_metadata.id, dir_id, file_path, file_type, file_metadata.file_state, file_data_id, file_mode, file_metadata.mod_time, file_metadata.creation_time, file_tracker.id, peer_id, file_meta_id, current_hash_id, file_tracker.file_state, log_time, file_data.id, file_hash, file_data.mod_time, file_size, file_data_b, file_data.creation_time from file_metadata
//	JOIN file_tracker on file_tracker.file_meta_id = file_metadata.id
//	JOIN file_data on file_tracker.current_hash_id = file_data.id
//	WHERE
//		current_hash_id NOT IN (
//			SELECT current_hash_id from file_metadata
//			where file_state = 'stored'
//			AND peer_id = $1
//		)
func (q *Queries) DownloadStoreBulk(ctx context.Context, db DBTX, peerID uuid.UUID) ([]*DownloadStoreBulkRow, error) {
	rows, err := db.Query(ctx, downloadStoreBulk, peerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DownloadStoreBulkRow{}
	for rows.Next() {
		var i DownloadStoreBulkRow
		if err := rows.Scan(
			&i.ID,
			&i.DirID,
			&i.FilePath,
			&i.FileType,
			&i.FileState,
			&i.FileDataID,
			&i.FileMode,
			&i.ModTime,
			&i.CreationTime,
			&i.ID_2,
			&i.PeerID,
			&i.FileMetaID,
			&i.CurrentHashID,
			&i.FileState_2,
			&i.LogTime,
			&i.ID_3,
			&i.FileHash,
			&i.ModTime_2,
			&i.FileSize,
			&i.FileDataB,
			&i.CreationTime_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFileTrackerMarkStored = `-- name: UpdateFileTrackerMarkStored :exec
INSERT INTO file_tracker (
    peer_id,
    file_meta_id,
    current_hash_id,
    file_state
) VALUES ($1, $2, $3, 'stored')
`

type UpdateFileTrackerMarkStoredParams struct {
	PeerID        uuid.UUID `json:"peer_id"`
	FileMetaID    int32     `json:"file_meta_id"`
	CurrentHashID int32     `json:"current_hash_id"`
}

// UpdateFileTrackerMarkStored
//
//	INSERT INTO file_tracker (
//	    peer_id,
//	    file_meta_id,
//	    current_hash_id,
//	    file_state
//	) VALUES ($1, $2, $3, 'stored')
func (q *Queries) UpdateFileTrackerMarkStored(ctx context.Context, db DBTX, arg *UpdateFileTrackerMarkStoredParams) error {
	_, err := db.Exec(ctx, updateFileTrackerMarkStored, arg.PeerID, arg.FileMetaID, arg.CurrentHashID)
	return err
}

const uploadStoreStepOnePeerDir = `-- name: UploadStoreStepOnePeerDir :one
INSERT INTO peer_dirs(peer_id,dir_path)
VALUES ($1, $2)
ON CONFLICT (uniq_dirs) DO NOTHING
RETURNING   
    id
`

type UploadStoreStepOnePeerDirParams struct {
	PeerID  pgtype.UUID `json:"peer_id"`
	DirPath string      `json:"dir_path"`
}

// UploadStoreStepOnePeerDir
//
//	INSERT INTO peer_dirs(peer_id,dir_path)
//	VALUES ($1, $2)
//	ON CONFLICT (uniq_dirs) DO NOTHING
//	RETURNING
//	    id
func (q *Queries) UploadStoreStepOnePeerDir(ctx context.Context, db DBTX, arg *UploadStoreStepOnePeerDirParams) (int32, error) {
	row := db.QueryRow(ctx, uploadStoreStepOnePeerDir, arg.PeerID, arg.DirPath)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const uploadStoreStepThreeUpdateMetadata = `-- name: UploadStoreStepThreeUpdateMetadata :one
INSERT INTO file_metadata(
    file_path, -- relative
    file_type,
    file_state, 
    file_data_id, -- file_data(id)
    file_mode,
    mod_time,
    dir_id
) VALUES ($1,$2,'store',$3,$4, $5, $6)
ON CONFLICT (file_path)
DO UPDATE
    SET 
        file_data_id = $4,
        mod_time = $6,
        file_state = 'store'
RETURNING 
    id
`

type UploadStoreStepThreeUpdateMetadataParams struct {
	FilePath   string             `json:"file_path"`
	FileType   string             `json:"file_type"`
	FileDataID int32              `json:"file_data_id"`
	FileMode   int32              `json:"file_mode"`
	ModTime    pgtype.Timestamptz `json:"mod_time"`
	DirID      *int32             `json:"dir_id"`
}

// UploadStoreStepThreeUpdateMetadata
//
//	INSERT INTO file_metadata(
//	    file_path, -- relative
//	    file_type,
//	    file_state,
//	    file_data_id, -- file_data(id)
//	    file_mode,
//	    mod_time,
//	    dir_id
//	) VALUES ($1,$2,'store',$3,$4, $5, $6)
//	ON CONFLICT (file_path)
//	DO UPDATE
//	    SET
//	        file_data_id = $4,
//	        mod_time = $6,
//	        file_state = 'store'
//	RETURNING
//	    id
func (q *Queries) UploadStoreStepThreeUpdateMetadata(ctx context.Context, db DBTX, arg *UploadStoreStepThreeUpdateMetadataParams) (int32, error) {
	row := db.QueryRow(ctx, uploadStoreStepThreeUpdateMetadata,
		arg.FilePath,
		arg.FileType,
		arg.FileDataID,
		arg.FileMode,
		arg.ModTime,
		arg.DirID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const uploadStoreStepTwoUploadFile = `-- name: UploadStoreStepTwoUploadFile :one
INSERT INTO file_data(
    mod_time,
    file_size,
    file_data_b
) VALUES ($1, $2, $3)
ON CONFLICT (file_hash) DO NOTHING
RETURNING 
    id, file_hash
`

type UploadStoreStepTwoUploadFileParams struct {
	ModTime   pgtype.Timestamptz `json:"mod_time"`
	FileSize  int32              `json:"file_size"`
	FileDataB []byte             `json:"file_data_b"`
}

type UploadStoreStepTwoUploadFileRow struct {
	ID       int32   `json:"id"`
	FileHash *string `json:"file_hash"`
}

// UploadStoreStepTwoUploadFile
//
//	INSERT INTO file_data(
//	    mod_time,
//	    file_size,
//	    file_data_b
//	) VALUES ($1, $2, $3)
//	ON CONFLICT (file_hash) DO NOTHING
//	RETURNING
//	    id, file_hash
func (q *Queries) UploadStoreStepTwoUploadFile(ctx context.Context, db DBTX, arg *UploadStoreStepTwoUploadFileParams) (*UploadStoreStepTwoUploadFileRow, error) {
	row := db.QueryRow(ctx, uploadStoreStepTwoUploadFile, arg.ModTime, arg.FileSize, arg.FileDataB)
	var i UploadStoreStepTwoUploadFileRow
	err := row.Scan(&i.ID, &i.FileHash)
	return &i, err
}
